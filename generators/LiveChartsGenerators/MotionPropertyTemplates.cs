// The MIT License(MIT)
//
// Copyright(c) 2021 Alberto Rodriguez Orozco & LiveCharts Contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace LiveChartsGenerators;

public static class MotionPropertyTemplates
{
    public static string GetTemplate(MotionProperty target)
    {
        var type = target.Property.ContainingType;

        var displayFormat = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameOnly,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters);

        var declaringType = type.ToDisplayString(displayFormat);

        return @$"// <auto-generated>
//     This code was generated by a LiveCharts source generator, do not edit.
// </auto-generated>

namespace {type.ContainingNamespace};

{GetFormattedAccessibility(type.DeclaredAccessibility)} partial class {declaringType}
{{
    /// <summary>
    ///    The <see cref=""{target.Property.Name}""/> property definition.
    /// </summary>
    public static readonly LiveChartsCore.Motion.PropertyDefinition {target.Property.Name}Property =
        new(g => (({declaringType})g).{target.Property.Name}, (g, v) => (({declaringType})g).{target.Property.Name} = ({target.Property.Type.ToDisplayString()})v, g => (({declaringType})g)._{target.Property.Name}MotionProperty);

    private readonly {GetMotionPropertyType(target.Property.Type)} _{target.Property.Name}MotionProperty = new({GetInitializationValue(target.Property)});

    /// <summary>
    ///     The <see cref=""{target.Property.Name}""/> motion property.
    /// </summary>
    /// <remarks>
    ///     This property is used to animate the <see cref=""{target.Property.Name}""/> property.
    /// </remarks>
    {GetFormattedAccessibility(target.Property.DeclaredAccessibility)} partial {target.Property.Type.ToDisplayString()} {target.Property.Name}
    {{
        {GetGetter(target)}
        {GetSetter(target)}
    }}

    partial void On{target.Property.Name}Changed({target.Property.Type.ToDisplayString()} value);
}}
";
    }

    private static string GetGetter(MotionProperty target)
    {
        // propertySymbol.GetMethod.IsImplicitlyDeclared
        // it seems that it does not work as expected on partial properties,
        // lets instead use the HasExplicitAcesseors property in the attribute.

        return target.Property.GetMethod is null
            ? string.Empty
            : !target.HasExplicitAcessors
                ? $"get => _{target.Property.Name}MotionProperty.GetMovement(this);"
                : "get;";
    }

    private static string GetSetter(MotionProperty target)
    {
        return target.Property.SetMethod is null
            ? string.Empty
            : !target.HasExplicitAcessors
                ? $"set {{ _{target.Property.Name}MotionProperty.SetMovement(value, this); On{target.Property.Name}Changed(value); }}"
                : "set;";
    }

    private static string GetFormattedAccessibility(Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Private => "private",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedAndInternal => "protected internal",
            Accessibility.ProtectedOrInternal => "private protected",
            Accessibility.NotApplicable => "not applicable",
            _ => "unknown"
        };
    }

    private static string GetMotionPropertyType(ITypeSymbol type)
    {
        return type.ToDisplayString() switch
        {
            "float" => "LiveChartsCore.Motion.FloatMotionProperty",
            "double" => "LiveChartsCore.Motion.DoubleMotionProperty",
            "double?" => "LiveChartsCore.Motion.NullableDoubleMotionProperty",
            "LiveChartsCore.Drawing.LvcColor" => "LiveChartsCore.Motion.ColorMotionProperty",
            "LiveChartsCore.Drawing.LvcPoint" => "LiveChartsCore.Motion.PointMotionProperty",
            "LiveChartsCore.Drawing.LvcSize" => "LiveChartsCore.Motion.SizeMotionProperty",
            "LiveChartsCore.Drawing.Padding" => "LiveChartsCore.Motion.PaddingMotionProperty",
            "SkiaSharp.SKMatrix" => "LiveChartsCore.SkiaSharpView.Motion.SKMatrixMotionProperty",
            _ => "UnsuportedType"
        };
    }

    private static string GetInitializationValue(IPropertySymbol propertySymbol)
    {
        var syntaxReference = propertySymbol.DeclaringSyntaxReferences.FirstOrDefault();
        if (syntaxReference != null)
        {
            var syntaxNode = syntaxReference.GetSyntax();
            // Check if the syntaxNode is a PropertyDeclarationSyntax
            if (syntaxNode is PropertyDeclarationSyntax propertyDeclaration)
            {
                var initializer = propertyDeclaration.Initializer;
                if (initializer != null)
                {
                    // Access the value of the initializer
                    var value = initializer.Value;
                    return value.ToString();
                }
            }
        }

        return string.Empty;
    }
}

// The MIT License(MIT)
//
// Copyright(c) 2021 Alberto Rodriguez Orozco & LiveCharts Contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

using System.Text;
using Microsoft.CodeAnalysis;

namespace LiveChartsGenerators;

public static class SourceGenerationHelper
{
    public const string Attribute = @"// <auto-generated>
//    This code was generated by a LiveCharts source generator, do not edit.
// </auto-generated>

#nullable enable
namespace LiveChartsCore.Generators;

/// <summary>
/// Marks a class to be generated as a XAML friendly object, LiveCharts will wrap the object in a XAML friendly object,
/// then when a property changes in the XAML object, it updates the LiveCharts object.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref=""XamlClassAttribute""/> class.
/// </remarks>
/// <param name=""basedOn"">The base type</param>
[System.AttributeUsage(System.AttributeTargets.Class)]
public class XamlClassAttribute(System.Type basedOn) : System.Attribute
{
    /// <summary>
    /// The base type.
    /// </summary>
    public System.Type BaseType { get; } = basedOn;

    /// <summary>
    /// Also maps the specified type.
    /// </summary>
    public System.Type Map { get; set; }

    /// <summary>
    /// The path to the map.
    /// </summary>
    public string MapPath { get; set; }

    /// <summary>
    /// The header to add to the generated file.
    /// </summary>
    public string? FileHeader { get; set; }

    /// <summary>
    /// A string with the property change handlers e.g.
    /// MyProperty{=}OnMyPropertyChanged{,}MyOtherProperty{=}OnMyOtherPropertyChanged.
    /// </summary>
    public string? PropertyChangeHandlers { get; set; }

    /// <summary>
    /// A string with the property type overrides e.g.
    /// MyProperty{=}double{,}MyOtherProperty{=}object.
    /// </summary>
    public string? PropertyTypeOverride { get; set; }
}";

    public static string GenerateXamlObject(XamlObject target)
    {
        var baseType = target.BasedOn.OriginalDefinition.ToDisplayString();

        return @$"// <auto-generated>
//     This code was generated by a LiveCharts source generator, do not edit.
// </auto-generated>

#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable IDE0052 // Remove unread private members
#pragma warning disable IDE1006 // Naming Styles
{target.FileHeader}
{GetNameSpaces()}
using LiveChartsCore.SkiaSharpView.TypeConverters;

namespace {target.NameSpace};

/// <summary>
/// A <see cref=""{baseType.Replace('<', '{').Replace('>', '}')}""/> for XAML.
/// </summary>
public partial class {target.Name}
{{
    private readonly {baseType} _baseType = new();

#region default values

{GetDefaultValues(target)}
#endregion

#region properties

{ConcatenateRegularProperties(target)}
#endregion

#region bindable properties

{ConcatenateBindableProperties(target)}
#endregion

#region events

{ConcatenateEvents(target)}
#endregion

#region methods

{ConcatenateMethods(target)}
#endregion

#region explicit methods

{ConcatenateExplicitMethods(target)}
#endregion

}}";
    }

    private static string GetDefaultValues(XamlObject target)
    {
        var sb = new StringBuilder();

        var fallBackInfo = GetFallbackInfo(target.BasedOn);

        _ = sb.AppendLine($"    private static readonly {fallBackInfo.Item1} {fallBackInfo.Item2} = new();");

        return sb.ToString();
    }

    private static string ConcatenateBindableProperties(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var pair in target.BindableProperties)
            foreach (var property in pair.Value)
                _ = sb.AppendLine(GetBindablePropertySyntax(target, property, pair.Key)).AppendLine();

        return sb.ToString();
    }

    private static string ConcatenateRegularProperties(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var property in target.NotBindableProperties)
            _ = sb
                .AppendLine(GetRegularPropertySyntax(property))
                .AppendLine();

        return sb.ToString();
    }

    private static string ConcatenateEvents(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var @event in target.Events)
            _ = sb
                .AppendLine(GetEventSyntax(@event))
                .AppendLine();

        return sb.ToString();
    }

    private static string ConcatenateMethods(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var method in target.Methods)
            _ = sb
                .AppendLine(GetMethodSyntax(method))
                .AppendLine();

        return sb.ToString();
    }

    private static string ConcatenateExplicitMethods(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var method in target.ExplicitMethods)
            _ = sb
                .AppendLine(GetExplicitMethodSyntax(method))
                .AppendLine();

        return sb.ToString();
    }

    private static string GetRegularPropertySyntax(IPropertySymbol property)
    {
        var propertyName = property.Name;
        var propertyType = property.Type.ToDisplayString();

        var propertyParts = propertyName.Split('.');

        // exception and special case for ChartElement
        if (propertyName.EndsWith("ChartElement"))
            return $"    public LiveChartsCore.Kernel.ChartElement ChartElement => _baseType;";

        if (propertyParts.Length > 1)
        {
            // this is an explicitly implemented property
            var path = string.Join(".", propertyParts, 0, propertyParts.Length - 1);
            var name = propertyParts[propertyParts.Length - 1];

            return property.SetMethod is null
                ? $"    {propertyType} {propertyName} => (({path})_baseType).{name};"
                : $"    {propertyType} {propertyName} {{ get => (({path})_baseType).{name}; set => (({path})_baseType).{name} = value; }}";
        }

        return property.SetMethod is null
            ? $"    public {propertyType} {propertyName} => _baseType.{propertyName};"
            : @$"    public {propertyType} {propertyName} {{ get => throw new System.NotImplementedException(""The generator was not able to generate the property syntax.""); set => throw new System.NotImplementedException(""The generator was not able to generate the property syntax.""); }}";
    }

    private static string GetEventSyntax(IEventSymbol @event) =>
        @$"    public new event {@event.Type.ToDisplayString()} {@event.Name}
    {{
        add => _baseType.{@event.Name} += value;
        remove => _baseType.{@event.Name} -= value;
    }}";

    private static string GetMethodSyntax(IMethodSymbol method)
    {
        var sb = new StringBuilder();
        var sb1 = new StringBuilder();
        var isFirst = true;

        foreach (var p in method.Parameters)
        {
            if (!isFirst)
            {
                _ = sb.Append(", ");
                _ = sb1.Append(", ");
            }

            _ = sb.Append($"{p.Type.ToDisplayString()} {p.Name}");
            _ = sb1.Append(p.Name);

            isFirst = false;
        }

        return @$"    public {method.ReturnType} {method.Name}({sb}) => _baseType.{method.Name}({sb1});";
    }

    private static string GetExplicitMethodSyntax(IMethodSymbol method)
    {
        var sb = new StringBuilder();
        var sb1 = new StringBuilder();
        var isFirst = true;

        foreach (var p in method.Parameters)
        {
            if (!isFirst)
            {
                _ = sb.Append(", ");
                _ = sb1.Append(", ");
            }

            _ = sb.Append($"{p.Type.ToDisplayString()} {p.Name}");
            _ = sb1.Append(p.Name);

            isFirst = false;
        }

        var nameSplit = method.Name.Split('.');
        var path = string.Join(".", nameSplit, 0, nameSplit.Length - 1);
        var actualName = nameSplit[nameSplit.Length - 1];

        return @$"    {method.ReturnType} {method.Name}({sb}) => (({path})_baseType).{actualName}({sb1});";
    }

    private static string GetBindablePropertySyntax(XamlObject target, IPropertySymbol property, string path)
    {
        var fallbackInfo = GetFallbackInfo(target.BasedOn);
        var fallBackName = path.Length > 0
            ? $"_default{path}"
            : fallbackInfo.Item2;

        if (path.Length == 0)
            path = "_baseType";

        var propertyName = property.Name;
        var propertyType = property.Type.ToDisplayString();
        var originalPropertyType = propertyType;

        if (target.OverridenTypes.TryGetValue(propertyName, out var overridenType))
            propertyType = overridenType;

        var sanitizedPropertyType = property.Type.IsReferenceType && propertyType.EndsWith("?")
            ? propertyType.Substring(0, propertyType.Length - 1)
            : propertyType;
        var bindableType = target.Name;

        var sb = new StringBuilder();

        var hasPublicSetter = property.SetMethod is not null && property.SetMethod.DeclaredAccessibility == Accessibility.Public;

        _ = sb
            .Append(@$"    public static readonly new BindableProperty {propertyName}Property = BindableProperty.Create(
        propertyName:       ""{propertyName}"",
        returnType:         typeof({sanitizedPropertyType}),
        declaringType:      typeof({bindableType}),
        defaultValue:       {fallBackName}.{propertyName}");

        if (hasPublicSetter)
        {
            _ = sb.Append(',').AppendLine();

            _ = target.PropertyChangedHandlers.TryGetValue(propertyName, out var handler)
                ? sb.Append(@$"        propertyChanged:    {handler}")
                : sb.Append(@$"        propertyChanged:    (BindableObject bo, object o, object n) => (({bindableType})bo).{path}.{propertyName} = ({propertyType})n");
        }

        _ = sb.Append(");");

        _ = sb.AppendLine();

        if (TypeConverters.TryGetValue(originalPropertyType, out var typeConverter))
            _ = sb.AppendLine(@$"    [System.ComponentModel.TypeConverter(typeof({typeConverter}))]");

        _ = sb.Append(@$"    public new {propertyType} {propertyName}
    {{
        get => ({propertyType})GetValue({propertyName}Property);
        set => SetValue({propertyName}Property, value);
    }}");

        return sb.ToString();
    }

    private static string GetNameSpaces()
        => "using Microsoft.Maui.Controls;";

    private static (string, string) GetFallbackInfo(ITypeSymbol target)
    {
        var baseType = target.OriginalDefinition.ToDisplayString();
        var baseTypeName = target.Name;

        return (baseType, $"_default{baseTypeName}");
    }

    private static Dictionary<string, string> TypeConverters { get; } = new()
    {
        ["LiveChartsCore.Drawing.Padding"] = "PaddingTypeConverter",
        ["LiveChartsCore.Drawing.LvcColor"] = "HexToLvcColorTypeConverter",
        ["LiveChartsCore.Drawing.LvcColor?"] = "HexToLvcColorTypeConverter",
        ["LiveChartsCore.Painting.Paint"] = "HexToPaintTypeConverter",
        ["LiveChartsCore.Painting.Paint?"] = "HexToPaintTypeConverter",
        ["System.Collections.Generic.IReadOnlyCollection<TModel>?"] = "ValuesTypeConverter"
    };
#pragma warning restore format
}

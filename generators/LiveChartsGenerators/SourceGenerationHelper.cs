// The MIT License(MIT)
//
// Copyright(c) 2021 Alberto Rodriguez Orozco & LiveCharts Contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

using System.Text;
using Microsoft.CodeAnalysis;

namespace LiveChartsGenerators;

public static class SourceGenerationHelper
{
    public const string Attribute = @"// <auto-generated>
//     This code was generated by a LiveCharts source generator, do not edit.
// </auto-generated>

namespace LiveChartsCore.Generators;

[System.AttributeUsage(System.AttributeTargets.Class)]
public class XamlClassAttribute : System.Attribute
{
    public XamlClassAttribute(System.Type basedOn, string fileHeader = null)
    {
        BaseType = basedOn;
        FileHeader = fileHeader;
    }

    public System.Type BaseType { get; }
    public string FileHeader { get; }
}";

    public static string GenerateXamlObject(XamlObject target)
    {
        var baseType = target.BasedOn.OriginalDefinition.ToDisplayString();

        return @$"// <auto-generated>
//     This code was generated by a LiveCharts source generator, do not edit.
// </auto-generated>

#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
{target.FileHeader}
{GetNameSpaces()}

namespace {target.NameSpace};

/// <summary>
/// A <see cref=""{baseType}""/> for XAML.
/// </summary>
public partial class {target.Name}
{{
    private readonly {baseType} _baseType = new();

#region properties

{ConcatenateRegularProperties(target)}
#endregion

#region bindable properties

{ConcatenateBindableProperties(target)}
#endregion

#region events

{ConcatenateEvents(target)}
#endregion

#region methods

{ConcatenateMethods(target)}
#endregion

#region explicit methods

{ConcatenateExplicitMethods(target)}
#endregion

{GetChangeBuilderHandler(target)}

}}";
    }

    private static string ConcatenateBindableProperties(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var property in target.BindableProperties)
            _ = sb.AppendLine(GetBindablePropertySyntax(target, property)).AppendLine();

        return sb.ToString();
    }

    private static string ConcatenateRegularProperties(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var property in target.NotBindableProperties)
            _ = sb
                .AppendLine(GetRegularPropertySyntax(property))
                .AppendLine();

        return sb.ToString();
    }

    private static string ConcatenateEvents(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var @event in target.Events)
            _ = sb
                .AppendLine(GetEventSyntax(@event))
                .AppendLine();

        return sb.ToString();
    }

    private static string ConcatenateMethods(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var method in target.Methods)
            _ = sb
                .AppendLine(GetMethodSyntax(method))
                .AppendLine();

        return sb.ToString();
    }

    private static string ConcatenateExplicitMethods(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var method in target.ExplicitMethods)
            _ = sb
                .AppendLine(GetExplicitMethodSyntax(method))
                .AppendLine();

        return sb.ToString();
    }

    private static string GetRegularPropertySyntax(IPropertySymbol property)
    {
        var propertyName = property.Name;
        var propertyType = property.Type.ToDisplayString();

        var propertyParts = propertyName.Split('.');

        // exception and special case for ChartElement
        if (propertyName.EndsWith("ChartElement"))
            return $"    public LiveChartsCore.Kernel.ChartElement ChartElement => _baseType;";

        if (propertyParts.Length > 1)
        {
            // this is an explicitly implemented property
            var path = string.Join(".", propertyParts, 0, propertyParts.Length - 1);
            var name = propertyParts[propertyParts.Length - 1];

            return property.SetMethod is null
                ? $"    {propertyType} {propertyName} => (({path})_baseType).{name};"
                : $"    {propertyType} {propertyName} {{ get => (({path})_baseType).{name}; set => (({path})_baseType).{name} = value; }}";
        }

        return property.SetMethod is null
            ? $"    public {propertyType} {propertyName} => _baseType.{propertyName};"
            : @$"    public {propertyType} {propertyName} {{ get => throw new System.NotImplementedException(""The generator was not able to generate the property syntax.""); set => throw new System.NotImplementedException(""The generator was not able to generate the property syntax.""); }}";
    }

    private static string GetEventSyntax(IEventSymbol @event) =>
        @$"    public event {@event.Type.ToDisplayString()} {@event.Name}
    {{
        add => _baseType.{@event.Name} += value;
        remove => _baseType.{@event.Name} -= value;
    }}";

    private static string GetMethodSyntax(IMethodSymbol method)
    {
        var sb = new StringBuilder();
        var sb1 = new StringBuilder();
        var isFirst = true;

        foreach (var p in method.Parameters)
        {
            if (!isFirst)
            {
                _ = sb.Append(", ");
                _ = sb1.Append(", ");
            }

            _ = sb.Append($"{p.Type.ToDisplayString()} {p.Name}");
            _ = sb1.Append(p.Name);

            isFirst = false;
        }

        return @$"    public {method.ReturnType} {method.Name}({sb}) => _baseType.{method.Name}({sb1});";
    }

    private static string GetExplicitMethodSyntax(IMethodSymbol method)
    {
        var sb = new StringBuilder();
        var sb1 = new StringBuilder();
        var isFirst = true;

        foreach (var p in method.Parameters)
        {
            if (!isFirst)
            {
                _ = sb.Append(", ");
                _ = sb1.Append(", ");
            }

            _ = sb.Append($"{p.Type.ToDisplayString()} {p.Name}");
            _ = sb1.Append(p.Name);

            isFirst = false;
        }

        var nameSplit = method.Name.Split('.');
        var path = string.Join(".", nameSplit, 0, nameSplit.Length - 1);
        var actualName = nameSplit[nameSplit.Length - 1];

        return @$"    {method.ReturnType} {method.Name}({sb}) => (({path})_baseType).{actualName}({sb1});";
    }

    private static string GetBindablePropertySyntax(XamlObject target, IPropertySymbol property)
    {
        var propertyName = property.Name;
        var propertyType = property.Type.ToDisplayString();
        var sanitizedPropertyType = property.Type.IsReferenceType && propertyType.EndsWith("?")
            ? propertyType.Substring(0, propertyType.Length - 1)
            : propertyType;
        var bindableType = target.Type.ToDisplayString();

        var sb = new StringBuilder();

        var hasPublicSetter = property.SetMethod is not null && property.SetMethod.DeclaredAccessibility == Accessibility.Public;

        _ = sb.AppendLine(@$"    public static readonly BindableProperty {propertyName}Property = BindableProperty.Create(
        propertyName:       ""{propertyName}"",
        returnType:         typeof({sanitizedPropertyType}),
        declaringType:      typeof({bindableType}),
        defaultValue:       {target.BasedOn.OriginalDefinition.ToDisplayString()}.DefaultValues.{propertyName}{(hasPublicSetter ? "," : string.Empty)}");

        if (hasPublicSetter)
            _ = sb.Append(@$"        propertyChanged:    GetOnChangeHandler<{propertyType}>((o, v) => o.{propertyName} = v)");

        _ = sb.Append(");");

        _ = sb.AppendLine();

        if (TypeConverters.TryGetValue(propertyType, out var typeConverter))
            _ = sb.AppendLine(@$"    [System.ComponentModel.TypeConverter(typeof({typeConverter}))]");

        _ = sb.Append(@$"    public {propertyType} {propertyName}
    {{
        get => ({propertyType})GetValue({propertyName}Property);
        set => SetValue({propertyName}Property, value);
    }}");

        return sb.ToString();
    }

    private static string GetNameSpaces()
        => "using Microsoft.Maui.Controls;";

    private static string GetChangeBuilderHandler(XamlObject target)
    {
        return @$"    private static BindableProperty.BindingPropertyChangedDelegate GetOnChangeHandler<T>(
        System.Action<{target.BasedOn.OriginalDefinition.ToDisplayString()}, T> setter) =>
            (BindableObject o, object oldValue, object newValue) =>
            {{
                if (o is not {target.Type.ToDisplayString()} bindableTarget) return;
                setter(bindableTarget._baseType, (T)newValue);
            }};";
    }

#pragma warning disable format
    private static Dictionary<string, string> TypeConverters { get; } = new()
    {
        ["LiveChartsCore.Drawing.Padding"] =    "LiveChartsCore.SkiaSharpView.TypeConverters.PaddingTypeConverter",
        ["LiveChartsCore.Painting.Paint"] =     "LiveChartsCore.SkiaSharpView.TypeConverters.HexToPaintTypeConverter",
        ["LiveChartsCore.Painting.Paint?"] =     "LiveChartsCore.SkiaSharpView.TypeConverters.HexToPaintTypeConverter"
    };
#pragma warning restore format
}

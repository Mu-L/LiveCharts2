// The MIT License(MIT)
//
// Copyright(c) 2021 Alberto Rodriguez Orozco & LiveCharts Contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

using System.Text;
using Microsoft.CodeAnalysis;

namespace LiveChartsGenerators;

public static class SourceGenerationHelper
{
    public const string Attribute = @"// <auto-generated>
//    This code was generated by a LiveCharts source generator, do not edit.
// </auto-generated>

#nullable enable
namespace LiveChartsCore.Generators;

/// <summary>
/// Marks a class to be generated as a XAML friendly object, LiveCharts will wrap the object in a XAML friendly object,
/// then when a property changes in the XAML object, it updates the LiveCharts object.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref=""XamlClassAttribute""/> class.
/// </remarks>
/// <param name=""basedOn"">The base type</param>
[System.AttributeUsage(System.AttributeTargets.Class)]
public class XamlClassAttribute(System.Type basedOn) : System.Attribute
{
    /// <summary>
    /// The base type.
    /// </summary>
    public System.Type BaseType { get; } = basedOn;

    /// <summary>
    /// Also maps the specified type.
    /// </summary>
    public System.Type? Map { get; set; }

    /// <summary>
    /// The path to the map.
    /// </summary>
    public string? MapPath { get; set; }

    /// <summary>
    /// The header to add to the generated file.
    /// </summary>
    public string? FileHeader { get; set; }

    /// <summary>
    /// A string with the property change map e.g.
    /// MyProperty{=}MyMapMethod{,}MyOtherProperty{=}MyOtherMapMethod.
    /// </summary>
    public string? PropertyChangeMap { get; set; }

    /// <summary>
    /// A string with the property type overrides e.g.
    /// MyProperty{=}double{,}MyOtherProperty{=}object.
    /// </summary>
    public string? PropertyTypeOverride { get; set; }

    /// <summary>
    /// Indicates whether the generator should generate the base type declaration, default is true.
    /// </summary>
    public bool GenerateBaseTypeDeclaration { get; set; } = true;
}

public class CommandParameters<T1, T2>(T1 parameter1, T2 parameter2)
{
    public T1 Parameter1 { get; set; } = parameter1;
    public T2 Parameter2 { get; set; } = parameter2;
}

public class CommandParameters<T1, T2, T3>(T1 parameter1, T2 parameter2, T3 parameter3)
{
    public T1 Parameter1 { get; set; } = parameter1;
    public T2 Parameter2 { get; set; } = parameter2;
    public T3 Parameter3 { get; set; } = parameter3;
}

public class CommandParameters<T1, T2, T3, T4>(T1 parameter1, T2 parameter2, T3 parameter3, T4 parameter4)
{
    public T1 Parameter1 { get; set; } = parameter1;
    public T2 Parameter2 { get; set; } = parameter2;
    public T3 Parameter3 { get; set; } = parameter3;
    public T4 Parameter4 { get; set; } = parameter4;
}

public static class CommandParameters
{
    public static CommandParameters<T1, T2> Create<T1, T2>(T1 first, T2 second)
        => new(first, second);

    public static CommandParameters<T1, T2, T3> Create<T1, T2, T3>(T1 first, T2 second, T3 third)
        => new(first, second, third);

    public static CommandParameters<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 first, T2 second, T3 third, T4 fourth)
        => new(first, second, third, fourth);
}
";

    public static string GenerateXamlObject(XamlObject target)
    {
        var baseType = target.BasedOn.OriginalDefinition.ToDisplayString();

        return @$"// <auto-generated>
//     This code was generated by a LiveCharts source generator, do not edit.
// </auto-generated>

#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable IDE0052 // Remove unread private members
#pragma warning disable IDE1006 // Naming Styles
{target.FileHeader}
using LiveChartsCore.SkiaSharpView.TypeConverters;

namespace {target.NameSpace};

/// <summary>
/// A <see cref=""{baseType.Replace('<', '{').Replace('>', '}')}""/> for XAML.
/// </summary>
public partial class {target.Name}
{{
    {(target.GenerateBaseTypeDeclaration ? $"private readonly {baseType} _baseType = new();" : string.Empty)}

#region default values

{(target.GenerateBaseTypeDeclaration ? GetDefaultValues(target) : string.Empty)}
#endregion

#region properties

{Concatenate(target.NotBindableProperties, GetRegularPropertySyntax)}
#endregion

#region bindable properties

{Concatenate(
    target.BindableProperties,
    pair => Concatenate(pair.Value, property => GetBindablePropertySyntax(target, property)))}
#endregion

#region events

{Concatenate(target.Events, e => GetEventSyntax(target, e))}
#endregion

#region methods

{Concatenate(target.Methods, GetMethodSyntax)}
#endregion

#region explicit methods

{Concatenate(target.ExplicitMethods, GetExplicitMethodSyntax)}
#endregion

    protected override void OnPropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
    {{
        base.OnPropertyChanged(propertyName);
        MapChangeToBaseType(propertyName);
        AlsoOnPropertyChanged(propertyName);
    }}

    partial void AlsoOnPropertyChanged(string? propertyName = null);

    private System.Collections.Generic.HashSet<string> _setCommands = [];

    private void MapChangeToBaseType(string? propertyName = null)
    {{
        switch (propertyName)
        {{
{GetChangesMap(target)}{GetCommandsChangesMap(target)}
            default:
                break;
        }}
    }}

    static {target.Type.Name}()
    {{
        OnTypeDefined();

{Concatenate(
    target.BindableProperties,
    pair => Concatenate(pair.Value, property => $"{property.Name}Property = {GetBindablePropertyDefinition(target, property, pair.Key)}", false),
    false)}
    }}

    static partial void OnTypeDefined();
}}";
    }

    private static string GetDefaultValues(XamlObject target)
    {
        var sb = new StringBuilder();

        var fallBackInfo = GetFallbackInfo(target.BasedOn);

        _ = sb.AppendLine($"    private static readonly {fallBackInfo.Item1} {fallBackInfo.Item2} = new();");

        return sb.ToString();
    }

    private static string GetRegularPropertySyntax(IPropertySymbol property)
    {
        var propertyName = property.Name;
        var propertyType = property.Type.ToDisplayString();

        var propertyParts = propertyName.Split('.');

        // exception and special case for ChartElement
        if (propertyName.EndsWith("ChartElement"))
            return $"    public LiveChartsCore.Kernel.ChartElement ChartElement => _baseType;";

        if (propertyParts.Length > 1)
        {
            // this is an explicitly implemented property
            var path = string.Join(".", propertyParts, 0, propertyParts.Length - 1);
            var name = propertyParts[propertyParts.Length - 1];

            return property.SetMethod is null
                ? $"    {propertyType} {propertyName} => (({path})_baseType).{name};"
                : $"    {propertyType} {propertyName} {{ get => (({path})_baseType).{name}; set => (({path})_baseType).{name} = value; }}";
        }

        return property.SetMethod is null
            ? $"    public {propertyType} {propertyName} => _baseType.{propertyName};"
            : @$"    public {propertyType} {propertyName} {{ get => throw new System.NotImplementedException(""The generator was not able to generate the property syntax.""); set => throw new System.NotImplementedException(""The generator was not able to generate the property syntax.""); }}";
    }

    private static string GetEventSyntax(XamlObject target, IEventSymbol @event) =>
        @$"    public new event {@event.Type.ToDisplayString()} {@event.Name}
    {{
        add => _baseType.{@event.Name} += value;
        remove => _baseType.{@event.Name} -= value;
    }}
{GetBindablePropertySyntax(target, $"{@event.Name}Command", "System.Windows.Input.ICommand", new(target.Name, "null"))}";

    private static string GetMethodSyntax(IMethodSymbol method)
    {
        var sb = new StringBuilder();
        var sb1 = new StringBuilder();
        var isFirst = true;

        foreach (var p in method.Parameters)
        {
            if (!isFirst)
            {
                _ = sb.Append(", ");
                _ = sb1.Append(", ");
            }

            _ = sb.Append($"{p.Type.ToDisplayString()} {p.Name}");
            _ = sb1.Append(p.Name);

            isFirst = false;
        }

        return @$"    public {method.ReturnType} {method.Name}({sb}) => _baseType.{method.Name}({sb1});";
    }

    private static string GetExplicitMethodSyntax(IMethodSymbol method)
    {
        var sb = new StringBuilder();
        var sb1 = new StringBuilder();
        var isFirst = true;

        foreach (var p in method.Parameters)
        {
            if (!isFirst)
            {
                _ = sb.Append(", ");
                _ = sb1.Append(", ");
            }

            _ = sb.Append($"{p.Type.ToDisplayString()} {p.Name}");
            _ = sb1.Append(p.Name);

            isFirst = false;
        }

        var nameSplit = method.Name.Split('.');
        var path = string.Join(".", nameSplit, 0, nameSplit.Length - 1);
        var actualName = nameSplit[nameSplit.Length - 1];

        return @$"    {method.ReturnType} {method.Name}({sb}) => (({path})_baseType).{actualName}({sb1});";
    }

    private static string GetChangesMap(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var pair in target.BindableProperties)
        {
            var path = pair.Key;
            if (pair.Key.Length == 0)
                path = "_baseType";

            foreach (var property in pair.Value)
            {
                var hasPublicSetter = property.SetMethod is not null && property.SetMethod.DeclaredAccessibility == Accessibility.Public;
                if (!hasPublicSetter) continue;

                var propertyType = property.Type.ToDisplayString();

                _ = target.PropertyChangedMap.TryGetValue(property.Name, out var map)
                    ? sb.AppendLine(@$"            case ""{property.Name}"": {map}(GetValue({property.Name}Property)); break;")
                    : sb.AppendLine(@$"            case ""{property.Name}"": {path}.{property.Name} = ({propertyType})GetValue({property.Name}Property); break;");
            }
        }

        return sb.ToString();
    }

    private static string GetCommandsChangesMap(XamlObject target)
    {
        var sb = new StringBuilder();

        foreach (var @event in target.Events)
        {
            var commandPropertyName = $"{@event.Name}Command";
            var delegateType = @event.Type as INamedTypeSymbol;
            var parametersCount = delegateType?.DelegateInvokeMethod?.Parameters.Length ?? 0;

            var parametersString = string.Join(", ", Enumerable.Range(0, parametersCount).Select(i => $"arg{i}"));
            var parametersObject = parametersCount <= 1
                ? parametersString
                : $"LiveChartsCore.Generators.CommandParameters.Create({parametersString})";

            _ = sb.AppendLine(@$"            case ""{commandPropertyName}"":
                if (!_setCommands.Contains(""{commandPropertyName}""))
                {{
                    _setCommands.Add(""{commandPropertyName}"");
                    _baseType.{@event.Name} += ({parametersString}) =>
                    {{
                        var commandParameter = {parametersObject};
                        if ({commandPropertyName} is null || !{commandPropertyName}.CanExecute(commandParameter)) return;
                        {commandPropertyName}.Execute(commandParameter);
                    }};
                }}
                break;");
        }

        return sb.ToString();
    }

    private static string GetBindablePropertySyntax(XamlObject target, IPropertySymbol property, BindablePropertyInitializer? initializer = null) =>
        GetBindablePropertySyntax(target, property.Name, property.Type.ToDisplayString(), initializer);

    private static string GetBindablePropertySyntax(XamlObject target, string propertyName, string propertyType, BindablePropertyInitializer? initializer)
    {
        var originalPropertyType = propertyType;

        if (target.OverridenTypes.TryGetValue(propertyName, out var overridenType))
            propertyType = overridenType;

        var sb = new StringBuilder();

        _ = sb
            .Append(@$"    public static readonly new Microsoft.Maui.Controls.BindableProperty {propertyName}Property");

        _ = initializer is not null
            ? sb.Append(" =").Append(GetBindablePropertyDefinition(propertyName, propertyType, initializer.BindableType, initializer.DefaultValue))
            : sb.Append(';').AppendLine();

        if (TypeConverters.TryGetValue(originalPropertyType, out var typeConverter))
            _ = sb.AppendLine(@$"    [System.ComponentModel.TypeConverter(typeof({typeConverter}))]");

        _ = sb.Append(@$"    public new {propertyType} {propertyName}
    {{
        get => ({propertyType})GetValue({propertyName}Property);
        set => SetValue({propertyName}Property, value);
    }}");

        return sb.ToString();
    }

    private static string GetBindablePropertyDefinition(XamlObject target, IPropertySymbol property, string path)
    {
        var fallbackInfo = GetFallbackInfo(target.BasedOn);
        var fallBackName = path.Length > 0
            ? $"_default{path}"
            : fallbackInfo.Item2;

        var propertyName = property.Name;
        var propertyType = property.Type.ToDisplayString();

        if (target.OverridenTypes.TryGetValue(propertyName, out var overridenType))
            propertyType = overridenType;

        var sanitizedPropertyType = property.Type.IsReferenceType && propertyType.EndsWith("?")
            ? propertyType.Substring(0, propertyType.Length - 1)
            : propertyType;

        return GetBindablePropertyDefinition(
            propertyName, sanitizedPropertyType, target.Name, $"{fallBackName}.{propertyName}");
    }


    private static string GetBindablePropertyDefinition(
        string propertyName, string propertyType, string bindableType, string defaultValue)
    {
        var sb = new StringBuilder();

        _ = sb
            .AppendLine(@$" Microsoft.Maui.Controls.BindableProperty.Create(propertyName: ""{propertyName}"", returnType: typeof({propertyType}), declaringType: typeof({bindableType}), defaultValue: {defaultValue});");

        return sb.ToString();
    }

    private static (string, string) GetFallbackInfo(ITypeSymbol target)
    {
        var baseType = target.OriginalDefinition.ToDisplayString();
        var baseTypeName = target.Name;

        return (baseType, $"_default{baseTypeName}");
    }

    private static Dictionary<string, string> TypeConverters { get; } = new()
    {
        ["LiveChartsCore.Drawing.Padding"] = "PaddingTypeConverter",
        ["LiveChartsCore.Measure.Margin"] = "MarginTypeConverter",
        ["LiveChartsCore.Drawing.LvcPoint"] = "PointTypeConverter",
        ["LiveChartsCore.Drawing.LvcPointD"] = "PointDTypeConverter",
        ["LiveChartsCore.Drawing.LvcColor"] = "HexToLvcColorTypeConverter",
        ["LiveChartsCore.Drawing.LvcColor?"] = "HexToLvcColorTypeConverter",
        ["LiveChartsCore.Painting.Paint"] = "HexToPaintTypeConverter",
        ["LiveChartsCore.Painting.Paint?"] = "HexToPaintTypeConverter",
        ["System.Collections.Generic.IReadOnlyCollection<TModel>?"] = "ValuesTypeConverter"
    };

    private static string Concatenate<TItem>(
        IEnumerable<TItem> propertyToWrite,
        Func<TItem, string> syntaxBuilder,
        bool appendLine = true)
    {
        var sb = new StringBuilder();

        foreach (var item in propertyToWrite)
        {
            _ = appendLine
                ? _ = sb.AppendLine(syntaxBuilder(item))
                : _ = sb.Append(syntaxBuilder(item));
        }

        return sb.ToString();
    }

    private class BindablePropertyInitializer(string bindableType, string defaultValue)
    {
        public string BindableType { get; set; } = bindableType;
        public string DefaultValue { get; set; } = defaultValue;
    }
}
